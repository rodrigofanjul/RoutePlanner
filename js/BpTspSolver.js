/*
This encapsulates reusable functionality for resolving TSP problems on
Google Maps.
The authors of this code are James Tolley <info [at] gmaptools.com>
and Geir K. Engdahl <geir.engdahl (at) gmail.com>

For the most up-to-date version of this file, see
http://code.google.com/p/google-maps-tsp-solver/

To receive updates, subscribe to google-maps-tsp-solver@googlegroups.com

version 1.0; 05/07/10

// Usage:
See http://code.google.com/p/google-maps-tsp-solver/
*/

(function() {

  var tsp; // singleton
  var gebMap; // The map DOM object
  var directionsPanel; // The driving directions DOM object
  var gebDirectionsResult; // The driving directions returned from GMAP API
  var gebDirectionsService;
  var gebGeocoder; // The geocoder for addresses
  var maxTspSize = 50; // A limit on the size of the problem, mostly to save Google servers from undue load.
  var maxTspBF = 0; // Max size for brute force, may seem conservative, but ma
  var maxTspDynamic = 15; // Max size for brute force, may seem conservative, but many browsers have limitations on run-time.
  var maxSize = 10; // Max number of waypoints in one Google driving directions request.
  var maxTripSentry = 2000000000; // Approx. 63 years., this long a route should not be reached...
  var avoidHighways = false; // Whether to avoid highways. False by default.
  var avoidTolls = false; // Whether to avoid toll roads. False by default.
  var EUROPE = [-5.863332, 81.434750, -6.704456, 74.786230, -34.492960, 62.807440, -30.837530, 30.816590, -15.764107, 29.735139, -9.611205, 35.985870, -5.653329, 35.894580, -5.401044, 35.937190, -5.377002, 35.879620, -5.345073, 35.865680, -5.261097, 35.760390, -5.001727, 35.734240, -3.105293, 35.432621, -2.922474, 35.472141, -2.914235, 35.353502, -2.946335, 35.324656, -2.963845, 35.316812, -2.970368, 35.300843, -2.972428, 35.285430, -2.951485, 35.263288, -2.929856, 35.269174, -2.912861, 35.287112, -2.159529, 35.779803, 3.541102, 37.759810, 11.600370, 37.858610, 11.595620, 35.538050, 13.002900, 34.000000, 33.271500, 33.997190, 34.769750, 34.854310, 35.266660, 35.625790, 36.236940, 35.806410, 36.768620, 36.195300, 36.754060, 36.570560, 39.642720, 36.647060, 40.840170, 37.092560, 41.288950, 37.026240, 42.398570, 37.054530, 43.272420, 37.242670, 44.328630, 36.914900, 44.996930, 37.199370, 44.519020, 38.649450, 44.183540, 39.276880, 44.879710, 39.640220, 44.507940, 40.075790, 43.981600, 40.164760, 43.759980, 41.039710, 44.851450, 41.068950, 44.997140, 41.265530, 45.039480, 41.289400, 45.136930, 41.349450, 45.181900, 41.401940, 45.256860, 41.431920, 45.316820, 41.446910, 45.371790, 41.415060, 45.449240, 41.405690, 45.609150, 41.341940, 45.694100, 41.340070, 45.684100, 41.291280, 45.726580, 41.234930, 45.883990, 41.178540, 46.006420, 41.161610, 46.111350, 41.161610, 46.196300, 41.174780, 46.288750, 41.167260, 46.336220, 41.122100, 46.376200, 41.080680, 46.446160, 41.063730, 46.493630, 41.046770, 46.653540, 41.091980, 46.678520, 41.163490, 46.753480, 41.293150, 46.636050, 41.400070, 46.443660, 41.465630, 46.346220, 41.538610, 46.358710, 41.596560, 46.286250, 41.637650, 46.241280, 41.652590, 46.218790, 41.704840, 46.258770, 41.745870, 46.318730, 41.760780, 46.388690, 41.818530, 46.423670, 41.863200, 46.436160, 41.911560, 46.421170, 41.948740, 46.338720, 41.965460, 46.266260, 42.019310, 46.181310, 42.030450, 46.103860, 42.043440, 45.988930, 42.060140, 45.923960, 42.100930, 45.866500, 42.132440, 45.801540, 42.138000, 45.726580, 42.178750, 45.659120, 42.213920, 45.654120, 42.258310, 45.716590, 42.269410, 45.774050, 42.284200, 45.786540, 42.326700, 45.766560, 42.363630, 45.781550, 42.420830, 45.801540, 42.466930, 45.791540, 42.498250, 45.701590, 42.512990, 45.616640, 42.544290, 45.569170, 42.555330, 45.449240, 42.559020, 45.361790, 42.557170, 45.329310, 42.592130, 45.241860, 42.676690, 45.169410, 42.718920, 45.076960, 42.744620, 44.997220, 42.754370, 45.000000, 75.000000, 39.671880, 81.472990, -5.863332, 81.434750];
  var OCEANIA = [8.951250E+01, -1.114336E+01, 6.166378E+01, -9.177713E+00, 4.465547E+01, -5.708778E+01, 1.797427E+02, -5.716482E+01, 1.799947E+02, 2.627781E+01, 1.321437E+02, 2.646478E+01, 1.301451E+02, 3.640314E+00, 1.299532E+02, -5.352926E-01, 1.310616E+02, -3.784815E+00, 1.302669E+02, -1.004378E+01, 1.182557E+02, -1.301165E+01, 1.028009E+02, -8.390453E+00, 8.951250E+01, -1.114336E+01];
  var NORTH_AMERICA = [-1.238894E+02, 3.001143E+01, -1.034398E+02, 6.882830E+00, -9.234289E+01, 1.447696E+01, -9.234211E+01, 1.447641E+01, -9.234124E+01, 1.447602E+01, -9.234031E+01, 1.447581E+01, -9.233936E+01, 1.447577E+01, -9.233841E+01, 1.447592E+01, -9.233752E+01, 1.447624E+01, -9.233670E+01, 1.447672E+01, -9.224479E+01, 1.454372E+01, -9.224380E+01, 1.454404E+01, -9.223935E+01, 1.454602E+01, -9.223755E+01, 1.454635E+01, -9.223540E+01, 1.454615E+01, -9.223315E+01, 1.454574E+01, -9.222939E+01, 1.454397E+01, -9.222737E+01, 1.454270E+01, -9.222632E+01, 1.454220E+01, -9.222517E+01, 1.454196E+01, -9.222212E+01, 1.454169E+01, -9.222077E+01, 1.454175E+01, -9.221687E+01, 1.454254E+01, -9.221607E+01, 1.454291E+01, -9.221536E+01, 1.454343E+01, -9.221341E+01, 1.454509E+01, -9.221266E+01, 1.454590E+01, -9.221210E+01, 1.454686E+01, -9.221176E+01, 1.454791E+01, -9.221121E+01, 1.455069E+01, -9.221113E+01, 1.455208E+01, -9.221162E+01, 1.455779E+01, -9.221132E+01, 1.455931E+01, -9.221073E+01, 1.456063E+01, -9.220993E+01, 1.456156E+01, -9.220889E+01, 1.456230E+01, -9.220624E+01, 1.456354E+01, -9.220402E+01, 1.456493E+01, -9.220182E+01, 1.456649E+01, -9.220092E+01, 1.456730E+01, -9.219899E+01, 1.456959E+01, -9.219760E+01, 1.457154E+01, -9.219636E+01, 1.457388E+01, -9.219545E+01, 1.457494E+01, -9.219367E+01, 1.457628E+01, -9.219176E+01, 1.457812E+01, -9.218783E+01, 1.458100E+01, -9.218563E+01, 1.458287E+01, -9.218369E+01, 1.458480E+01, -9.218297E+01, 1.458570E+01, -9.218248E+01, 1.458675E+01, -9.218065E+01, 1.459263E+01, -9.218010E+01, 1.459541E+01, -9.217977E+01, 1.459873E+01, -9.217939E+01, 1.460059E+01, -9.217831E+01, 1.460286E+01, -9.217621E+01, 1.460874E+01, -9.217556E+01, 1.461250E+01, -9.217556E+01, 1.461534E+01, -9.217477E+01, 1.461807E+01, -9.217434E+01, 1.462110E+01, -9.217378E+01, 1.462246E+01, -9.217183E+01, 1.462523E+01, -9.217098E+01, 1.462678E+01, -9.216927E+01, 1.462926E+01, -9.216790E+01, 1.463192E+01, -9.216693E+01, 1.463468E+01, -9.216575E+01, 1.463635E+01, -9.216350E+01, 1.463701E+01, -9.216263E+01, 1.463753E+01, -9.216188E+01, 1.463823E+01, -9.215999E+01, 1.464039E+01, -9.215941E+01, 1.464122E+01, -9.215900E+01, 1.464215E+01, -9.215814E+01, 1.464480E+01, -9.215781E+01, 1.464629E+01, -9.215756E+01, 1.464651E+01, -9.215473E+01, 1.464738E+01, -9.215373E+01, 1.464781E+01, -9.215054E+01, 1.464964E+01, -9.214624E+01, 1.465246E+01, -9.214532E+01, 1.465324E+01, -9.214462E+01, 1.465422E+01, -9.214354E+01, 1.465617E+01, -9.214241E+01, 1.465738E+01, -9.214175E+01, 1.465828E+01, -9.214130E+01, 1.465930E+01, -9.214109E+01, 1.466039E+01, -9.214093E+01, 1.466348E+01, -9.214111E+01, 1.466439E+01, -9.214146E+01, 1.466524E+01, -9.214260E+01, 1.466744E+01, -9.214298E+01, 1.467051E+01, -9.214312E+01, 1.467375E+01, -9.214262E+01, 1.467706E+01, -9.214262E+01, 1.467958E+01, -9.214197E+01, 1.468120E+01, -9.213873E+01, 1.468621E+01, -9.213845E+01, 1.468707E+01, -9.213833E+01, 1.468796E+01, -9.213837E+01, 1.468886E+01, -9.213858E+01, 1.468974E+01, -9.213995E+01, 1.469371E+01, -9.214196E+01, 1.469637E+01, -9.214428E+01, 1.470553E+01, -9.214331E+01, 1.471094E+01, -9.214360E+01, 1.471355E+01, -9.214319E+01, 1.471615E+01, -9.214315E+01, 1.471736E+01, -9.214341E+01, 1.471854E+01, -9.214477E+01, 1.472228E+01, -9.214830E+01, 1.472695E+01, -9.215077E+01, 1.472920E+01, -9.215124E+01, 1.473111E+01, -9.215349E+01, 1.473647E+01, -9.215400E+01, 1.473738E+01, -9.215468E+01, 1.473817E+01, -9.215551E+01, 1.473880E+01, -9.215765E+01, 1.474008E+01, -9.215942E+01, 1.474418E+01, -9.216184E+01, 1.474877E+01, -9.216298E+01, 1.475154E+01, -9.216696E+01, 1.475791E+01, -9.216740E+01, 1.475890E+01, -9.216729E+01, 1.476016E+01, -9.216669E+01, 1.476215E+01, -9.216576E+01, 1.476426E+01, -9.216515E+01, 1.476547E+01, -9.216334E+01, 1.476713E+01, -9.216284E+01, 1.476787E+01, -9.216164E+01, 1.477120E+01, -9.216139E+01, 1.477278E+01, -9.216139E+01, 1.477611E+01, -9.216160E+01, 1.477755E+01, -9.216243E+01, 1.478032E+01, -9.216376E+01, 1.478342E+01, -9.216454E+01, 1.478464E+01, -9.216606E+01, 1.478642E+01, -9.216854E+01, 1.478990E+01, -9.216944E+01, 1.479152E+01, -9.216984E+01, 1.479331E+01, -9.217035E+01, 1.479465E+01, -9.217136E+01, 1.479647E+01, -9.217230E+01, 1.480145E+01, -9.217275E+01, 1.480279E+01, -9.217488E+01, 1.480731E+01, -9.217677E+01, 1.481013E+01, -9.217802E+01, 1.481162E+01, -9.217827E+01, 1.481247E+01, -9.217780E+01, 1.481788E+01, -9.217786E+01, 1.481923E+01, -9.217833E+01, 1.482184E+01, -9.217833E+01, 1.482472E+01, -9.217854E+01, 1.482616E+01, -9.218000E+01, 1.483101E+01, -9.218002E+01, 1.483403E+01, -9.218078E+01, 1.484307E+01, -9.217954E+01, 1.484697E+01, -9.217858E+01, 1.484887E+01, -9.217767E+01, 1.485146E+01, -9.217659E+01, 1.485318E+01, -9.217609E+01, 1.485425E+01, -9.217557E+01, 1.485582E+01, -9.217454E+01, 1.485702E+01, -9.217338E+01, 1.485901E+01, -9.217033E+01, 1.486091E+01, -9.216568E+01, 1.486326E+01, -9.216124E+01, 1.486604E+01, -9.215898E+01, 1.486790E+01, -9.215707E+01, 1.486909E+01, -9.215618E+01, 1.486980E+01, -9.214924E+01, 1.487674E+01, -9.214831E+01, 1.487804E+01, -9.214756E+01, 1.487954E+01, -9.214427E+01, 1.488257E+01, -9.214254E+01, 1.488523E+01, -9.213954E+01, 1.488931E+01, -9.213904E+01, 1.489019E+01, -9.213793E+01, 1.489269E+01, -9.213688E+01, 1.489606E+01, -9.213669E+01, 1.489698E+01, -9.213668E+01, 1.489791E+01, -9.213724E+01, 1.490434E+01, -9.213743E+01, 1.490533E+01, -9.213827E+01, 1.490811E+01, -9.213905E+01, 1.490996E+01, -9.213837E+01, 1.491310E+01, -9.213794E+01, 1.491641E+01, -9.213792E+01, 1.491750E+01, -9.213826E+01, 1.492132E+01, -9.213847E+01, 1.492235E+01, -9.213941E+01, 1.492539E+01, -9.213978E+01, 1.492742E+01, -9.214041E+01, 1.492961E+01, -9.214038E+01, 1.492999E+01, -9.213794E+01, 1.493649E+01, -9.213764E+01, 1.493810E+01, -9.213769E+01, 1.493891E+01, -9.213812E+01, 1.494190E+01, -9.213839E+01, 1.494295E+01, -9.213888E+01, 1.494392E+01, -9.213957E+01, 1.494477E+01, -9.214043E+01, 1.494544E+01, -9.214233E+01, 1.494661E+01, -9.214312E+01, 1.494742E+01, -9.214361E+01, 1.494832E+01, -9.214390E+01, 1.494999E+01, -9.214390E+01, 1.495145E+01, -9.214343E+01, 1.495260E+01, -9.214270E+01, 1.495512E+01, -9.214202E+01, 1.495927E+01, -9.214202E+01, 1.496109E+01, -9.214238E+01, 1.496403E+01, -9.214254E+01, 1.496762E+01, -9.214287E+01, 1.496961E+01, -9.214095E+01, 1.497296E+01, -9.214071E+01, 1.497390E+01, -9.214065E+01, 1.497486E+01, -9.214077E+01, 1.497582E+01, -9.214108E+01, 1.497674E+01, -9.214331E+01, 1.498171E+01, -9.214514E+01, 1.498452E+01, -9.214536E+01, 1.498673E+01, -9.214575E+01, 1.498889E+01, -9.214500E+01, 1.499265E+01, -9.214312E+01, 1.499600E+01, -9.214176E+01, 1.499758E+01, -9.214034E+01, 1.499953E+01, -9.213731E+01, 1.500256E+01, -9.213313E+01, 1.500538E+01, -9.213132E+01, 1.500740E+01, -9.212924E+01, 1.500896E+01, -9.212758E+01, 1.501063E+01, -9.212590E+01, 1.501257E+01, -9.212425E+01, 1.501398E+01, -9.212328E+01, 1.501503E+01, -9.212283E+01, 1.501516E+01, -9.211543E+01, 1.501371E+01, -9.211444E+01, 1.501361E+01, -9.210994E+01, 1.501369E+01, -9.210712E+01, 1.501420E+01, -9.210403E+01, 1.501446E+01, -9.210286E+01, 1.501470E+01, -9.210076E+01, 1.501540E+01, -9.209757E+01, 1.501589E+01, -9.209630E+01, 1.501626E+01, -9.209380E+01, 1.501737E+01, -9.209098E+01, 1.501927E+01, -9.208909E+01, 1.502106E+01, -9.208735E+01, 1.502215E+01, -9.208620E+01, 1.502313E+01, -9.208466E+01, 1.502493E+01, -9.208313E+01, 1.502647E+01, -9.208219E+01, 1.502776E+01, -9.208077E+01, 1.503078E+01, -9.207993E+01, 1.503356E+01, -9.207935E+01, 1.503636E+01, -9.207822E+01, 1.503923E+01, -9.207727E+01, 1.504210E+01, -9.207215E+01, 1.505061E+01, -9.206955E+01, 1.505431E+01, -9.206904E+01, 1.505519E+01, -9.206793E+01, 1.505769E+01, -9.206758E+01, 1.505883E+01, -9.206703E+01, 1.506188E+01, -9.206694E+01, 1.506281E+01, -9.206704E+01, 1.506374E+01, -9.206841E+01, 1.506741E+01, -9.206927E+01, 1.506917E+01, -9.206937E+01, 1.507022E+01, -9.206706E+01, 1.507170E+01, -9.206374E+01, 1.507324E+01, -9.206288E+01, 1.507375E+01, -9.206213E+01, 1.507442E+01, -9.206154E+01, 1.507522E+01, -9.206111E+01, 1.507612E+01, -9.206088E+01, 1.507710E+01, -9.206084E+01, 1.507810E+01, -9.206101E+01, 1.507908E+01, -9.206136E+01, 1.508002E+01, -9.206190E+01, 1.508086E+01, -9.209608E+01, 1.512449E+01, -9.220534E+01, 1.526263E+01, -9.214514E+01, 1.536440E+01, -9.211847E+01, 1.540996E+01, -9.208888E+01, 1.545995E+01, -9.198452E+01, 1.563592E+01, -9.195460E+01, 1.568605E+01, -9.193209E+01, 1.572468E+01, -9.191024E+01, 1.576105E+01, -9.184071E+01, 1.587827E+01, -9.182180E+01, 1.590969E+01, -9.180125E+01, 1.594468E+01, -9.177849E+01, 1.598298E+01, -9.174266E+01, 1.604243E+01, -9.172900E+01, 1.606784E+01, -9.168134E+01, 1.606878E+01, -9.132089E+01, 1.606878E+01, -9.095679E+01, 1.606911E+01, -9.043956E+01, 1.607307E+01, -9.042128E+01, 1.609755E+01, -9.042128E+01, 1.617085E+01, -9.042170E+01, 1.625853E+01, -9.036597E+01, 1.637167E+01, -9.038612E+01, 1.641403E+01, -9.047572E+01, 1.646254E+01, -9.054388E+01, 1.648269E+01, -9.055331E+01, 1.648474E+01, -9.058075E+01, 1.647693E+01, -9.060904E+01, 1.651845E+01, -9.061633E+01, 1.652708E+01, -9.062018E+01, 1.657474E+01, -9.065191E+01, 1.663554E+01, -9.066902E+01, 1.668137E+01, -9.070356E+01, 1.672347E+01, -9.079880E+01, 1.680564E+01, -9.087311E+01, 1.683169E+01, -9.093067E+01, 1.685673E+01, -9.095912E+01, 1.690405E+01, -9.105379E+01, 1.691360E+01, -9.111805E+01, 1.700606E+01, -9.114732E+01, 1.701192E+01, -9.122254E+01, 1.709838E+01, -9.125930E+01, 1.711198E+01, -9.126217E+01, 1.718693E+01, -9.134037E+01, 1.718369E+01, -9.137701E+01, 1.720939E+01, -9.141790E+01, 1.721305E+01, -9.143341E+01, 1.724601E+01, -9.098790E+01, 1.724613E+01, -9.098697E+01, 1.724621E+01, -9.098606E+01, 1.724648E+01, -9.098523E+01, 1.724690E+01, -9.098448E+01, 1.724748E+01, -9.098386E+01, 1.724819E+01, -9.098338E+01, 1.724899E+01, -9.098306E+01, 1.724988E+01, -9.098292E+01, 1.725081E+01, -9.098238E+01, 1.725917E+01, -9.098231E+01, 1.727700E+01, -9.098265E+01, 1.779505E+01, -9.098253E+01, 1.780936E+01, -8.984645E+01, 1.781083E+01, -8.913910E+01, 1.781344E+01, -8.913973E+01, 1.795423E+01, -8.902484E+01, 1.799950E+01, -8.899783E+01, 1.795056E+01, -8.898711E+01, 1.794322E+01, -8.894982E+01, 1.794975E+01, -8.893739E+01, 1.792976E+01, -8.892410E+01, 1.791508E+01, -8.891209E+01, 1.790611E+01, -8.888123E+01, 1.789264E+01, -8.885808E+01, 1.789101E+01, -8.884036E+01, 1.792890E+01, -8.878258E+01, 1.797350E+01, -8.875998E+01, 1.802208E+01, -8.870053E+01, 1.807303E+01, -8.866034E+01, 1.813192E+01, -8.864108E+01, 1.818045E+01, -8.860090E+01, 1.823771E+01, -8.856227E+01, 1.832867E+01, -8.854260E+01, 1.835952E+01, -8.854595E+01, 1.838234E+01, -8.852891E+01, 1.840783E+01, -8.851610E+01, 1.846097E+01, -8.847518E+01, 1.848961E+01, -8.844756E+01, 1.847362E+01, -8.840121E+01, 1.849327E+01, -8.838969E+01, 1.848000E+01, -8.837981E+01, 1.847636E+01, -8.832686E+01, 1.848703E+01, -8.830162E+01, 1.848182E+01, -8.828955E+01, 1.846881E+01, -8.828926E+01, 1.841987E+01, -8.803266E+01, 1.841814E+01, -8.803614E+01, 1.816812E+01, -8.788512E+01, 1.816671E+01, -8.774311E+01, 1.816960E+01, -8.549087E+01, 1.819755E+01, -8.679214E+01, 2.450671E+01, -8.289581E+01, 2.395012E+01, -7.984516E+01, 2.454200E+01, -7.918945E+01, 2.804479E+01, -6.120258E+01, 2.463857E+01, -3.448789E+01, 6.281725E+01, -6.676794E+00, 7.479839E+01, -5.198412E+00, 8.504177E+01, -1.799999E+02, 8.503695E+01, -1.799999E+02, 6.932269E+00, -1.238894E+02, 3.001143E+01];
  var CENTRAL_AMERICA = [-61.784366, 11.703881, -68.872390, 11.770740, -69.786190, 12.217660, -70.543370, 12.318460, -71.933610, 13.138890, -76.776730, 10.455670, -77.279320, 8.939471, -77.354180, 8.637726, -77.434730, 8.514803, -77.381160, 8.468130, -77.107670, 7.926607, -77.301480, 7.866126, -77.327350, 7.756293, -77.483060, 7.553615, -77.578360, 7.488933, -77.714080, 7.666233, -77.685240, 7.498363, -77.757270, 7.441080, -77.811990, 7.437993, -77.883000, 7.217441, -78.078860, 7.052386, -80.763650, 3.299301, -95.335580, 3.283755, -99.827330, 9.313548, -92.342890, 14.476960, -92.342110, 14.476410, -92.341240, 14.476020, -92.340310, 14.475810, -92.339360, 14.475770, -92.338410, 14.475920, -92.337520, 14.476240, -92.336700, 14.476720, -92.244790, 14.543720, -92.243800, 14.544040, -92.239350, 14.546020, -92.237550, 14.546350, -92.235400, 14.546150, -92.233150, 14.545740, -92.229390, 14.543970, -92.227370, 14.542700, -92.226320, 14.542200, -92.225170, 14.541960, -92.222120, 14.541690, -92.220770, 14.541750, -92.216870, 14.542540, -92.216070, 14.542910, -92.215360, 14.543430, -92.213410, 14.545090, -92.212660, 14.545900, -92.212100, 14.546860, -92.211760, 14.547910, -92.211210, 14.550690, -92.211130, 14.552080, -92.211620, 14.557790, -92.211320, 14.559310, -92.210730, 14.560630, -92.209930, 14.561560, -92.208890, 14.562300, -92.206240, 14.563540, -92.204020, 14.564930, -92.201820, 14.566490, -92.200920, 14.567300, -92.198990, 14.569590, -92.197600, 14.571540, -92.196360, 14.573880, -92.195450, 14.574940, -92.193670, 14.576280, -92.191760, 14.578120, -92.187830, 14.581000, -92.185630, 14.582870, -92.183690, 14.584800, -92.182970, 14.585700, -92.182480, 14.586750, -92.180650, 14.592630, -92.180100, 14.595410, -92.179770, 14.598730, -92.179390, 14.600590, -92.178310, 14.602860, -92.176210, 14.608740, -92.175560, 14.612500, -92.175560, 14.615340, -92.174770, 14.618070, -92.174340, 14.621100, -92.173780, 14.622460, -92.171830, 14.625230, -92.170980, 14.626780, -92.169270, 14.629260, -92.167900, 14.631920, -92.166930, 14.634680, -92.165750, 14.636350, -92.163500, 14.637010, -92.162630, 14.637530, -92.161880, 14.638230, -92.159990, 14.640390, -92.159410, 14.641220, -92.159000, 14.642150, -92.158140, 14.644800, -92.157810, 14.646290, -92.157560, 14.646510, -92.154730, 14.647380, -92.153730, 14.647810, -92.150540, 14.649640, -92.146240, 14.652460, -92.145320, 14.653240, -92.144620, 14.654220, -92.143540, 14.656170, -92.142410, 14.657380, -92.141750, 14.658280, -92.141300, 14.659300, -92.141090, 14.660390, -92.140930, 14.663480, -92.141110, 14.664390, -92.141460, 14.665240, -92.142600, 14.667440, -92.142980, 14.670510, -92.143120, 14.673750, -92.142620, 14.677060, -92.142620, 14.679580, -92.141970, 14.681200, -92.138730, 14.686210, -92.138450, 14.687070, -92.138330, 14.687960, -92.138370, 14.688860, -92.138580, 14.689740, -92.139950, 14.693710, -92.141960, 14.696370, -92.144280, 14.705530, -92.143310, 14.710940, -92.143600, 14.713550, -92.143190, 14.716150, -92.143150, 14.717360, -92.143410, 14.718540, -92.144770, 14.722280, -92.148300, 14.726950, -92.150770, 14.729200, -92.151240, 14.731110, -92.153490, 14.736470, -92.154000, 14.737380, -92.154680, 14.738170, -92.155510, 14.738800, -92.157650, 14.740080, -92.159420, 14.744180, -92.161840, 14.748770, -92.162980, 14.751540, -92.166960, 14.757910, -92.167400, 14.758900, -92.167290, 14.760160, -92.166690, 14.762150, -92.165760, 14.764260, -92.165150, 14.765470, -92.163340, 14.767130, -92.162840, 14.767870, -92.161640, 14.771200, -92.161390, 14.772780, -92.161390, 14.776110, -92.161600, 14.777550, -92.162430, 14.780320, -92.163760, 14.783420, -92.164540, 14.784640, -92.166060, 14.786420, -92.168540, 14.789900, -92.169440, 14.791520, -92.169840, 14.793310, -92.170350, 14.794650, -92.171360, 14.796470, -92.172300, 14.801450, -92.172750, 14.802790, -92.174880, 14.807310, -92.176770, 14.810130, -92.178020, 14.811620, -92.178270, 14.812470, -92.177800, 14.817880, -92.177860, 14.819230, -92.178330, 14.821840, -92.178330, 14.824720, -92.178540, 14.826160, -92.180000, 14.831010, -92.180020, 14.834030, -92.180780, 14.843070, -92.179540, 14.846970, -92.178580, 14.848870, -92.177670, 14.851460, -92.176590, 14.853180, -92.176090, 14.854250, -92.175570, 14.855820, -92.174540, 14.857020, -92.173380, 14.859010, -92.170330, 14.860910, -92.165680, 14.863260, -92.161240, 14.866040, -92.158980, 14.867900, -92.157070, 14.869090, -92.156180, 14.869800, -92.149240, 14.876740, -92.148310, 14.878040, -92.147560, 14.879540, -92.144270, 14.882570, -92.142540, 14.885230, -92.139540, 14.889310, -92.139040, 14.890190, -92.137930, 14.892690, -92.136880, 14.896060, -92.136690, 14.896980, -92.136680, 14.897910, -92.137240, 14.904340, -92.137430, 14.905330, -92.138270, 14.908110, -92.139050, 14.909960, -92.138370, 14.913100, -92.137940, 14.916410, -92.137920, 14.917500, -92.138260, 14.921320, -92.138470, 14.922350, -92.139410, 14.925390, -92.139780, 14.927420, -92.140410, 14.929610, -92.140380, 14.929990, -92.137940, 14.936490, -92.137640, 14.938100, -92.137690, 14.938910, -92.138120, 14.941900, -92.138390, 14.942950, -92.138880, 14.943920, -92.139570, 14.944770, -92.140430, 14.945440, -92.142330, 14.946610, -92.143120, 14.947420, -92.143610, 14.948320, -92.143900, 14.949990, -92.143900, 14.951450, -92.143430, 14.952600, -92.142700, 14.955120, -92.142020, 14.959270, -92.142020, 14.961090, -92.142380, 14.964030, -92.142540, 14.967620, -92.142870, 14.969610, -92.140950, 14.972960, -92.140710, 14.973900, -92.140650, 14.974860, -92.140770, 14.975820, -92.141080, 14.976740, -92.143310, 14.981710, -92.145140, 14.984520, -92.145360, 14.986730, -92.145750, 14.988890, -92.145000, 14.992650, -92.143120, 14.996000, -92.141760, 14.997580, -92.140340, 14.999530, -92.137310, 15.002560, -92.133130, 15.005380, -92.131320, 15.007400, -92.129240, 15.008960, -92.127580, 15.010630, -92.125900, 15.012570, -92.124250, 15.013980, -92.123280, 15.015030, -92.122830, 15.015160, -92.115430, 15.013710, -92.114440, 15.013610, -92.109940, 15.013690, -92.107120, 15.014200, -92.104030, 15.014460, -92.102860, 15.014700, -92.100760, 15.015400, -92.097570, 15.015890, -92.096300, 15.016260, -92.093800, 15.017370, -92.090980, 15.019270, -92.089090, 15.021060, -92.087350, 15.022150, -92.086200, 15.023130, -92.084660, 15.024930, -92.083130, 15.026470, -92.082190, 15.027760, -92.080770, 15.030780, -92.079930, 15.033560, -92.079350, 15.036360, -92.078220, 15.039230, -92.077270, 15.042100, -92.072150, 15.050610, -92.069550, 15.054310, -92.069040, 15.055190, -92.067930, 15.057690, -92.067580, 15.058830, -92.067030, 15.061880, -92.066940, 15.062810, -92.067040, 15.063740, -92.068410, 15.067410, -92.069270, 15.069170, -92.069370, 15.070220, -92.067060, 15.071700, -92.063740, 15.073240, -92.062880, 15.073750, -92.062130, 15.074420, -92.061540, 15.075220, -92.061110, 15.076120, -92.060880, 15.077100, -92.060840, 15.078100, -92.061010, 15.079080, -92.061360, 15.080020, -92.061900, 15.080860, -92.096080, 15.124490, -92.205340, 15.262630, -92.145140, 15.364400, -92.118470, 15.409960, -92.088880, 15.459950, -91.984520, 15.635920, -91.954600, 15.686050, -91.932090, 15.724680, -91.910240, 15.761050, -91.840710, 15.878270, -91.821800, 15.909690, -91.801250, 15.944680, -91.778490, 15.982980, -91.742660, 16.042430, -91.729000, 16.067840, -91.681340, 16.068780, -91.320890, 16.068780, -90.956790, 16.069110, -90.439560, 16.073070, -90.421280, 16.097550, -90.421280, 16.170850, -90.421700, 16.258530, -90.365970, 16.371670, -90.386120, 16.414030, -90.475720, 16.462540, -90.543880, 16.482690, -90.553310, 16.484740, -90.580750, 16.476930, -90.609040, 16.518450, -90.616330, 16.527080, -90.620180, 16.574740, -90.651910, 16.635540, -90.669020, 16.681370, -90.703560, 16.723470, -90.798800, 16.805640, -90.873110, 16.831690, -90.930670, 16.856730, -90.959120, 16.904050, -91.053790, 16.913600, -91.118050, 17.006060, -91.147320, 17.011920, -91.222540, 17.098380, -91.259300, 17.111980, -91.262170, 17.186930, -91.340370, 17.183690, -91.377010, 17.209390, -91.417900, 17.213050, -91.433410, 17.246010, -90.987900, 17.246130, -90.986970, 17.246210, -90.986060, 17.246480, -90.985230, 17.246900, -90.984480, 17.247480, -90.983860, 17.248190, -90.983380, 17.248990, -90.983060, 17.249880, -90.982920, 17.250810, -90.982380, 17.259170, -90.982310, 17.277000, -90.982650, 17.795050, -90.982530, 17.809360, -89.846450, 17.810830, -89.139100, 17.813440, -89.139730, 17.954230, -89.024840, 17.999500, -88.997830, 17.950560, -88.987110, 17.943220, -88.949820, 17.949750, -88.937390, 17.929760, -88.924100, 17.915080, -88.912090, 17.906110, -88.881230, 17.892640, -88.858080, 17.891010, -88.840360, 17.928900, -88.782580, 17.973500, -88.759980, 18.022080, -88.700530, 18.073030, -88.660340, 18.131920, -88.641080, 18.180450, -88.600900, 18.237710, -88.562270, 18.328670, -88.542600, 18.359520, -88.545950, 18.382340, -88.528910, 18.407830, -88.516100, 18.460970, -88.475180, 18.489610, -88.447560, 18.473620, -88.401210, 18.493270, -88.389690, 18.480000, -88.379810, 18.476360, -88.326860, 18.487030, -88.301620, 18.481820, -88.289550, 18.468810, -88.289260, 18.419870, -88.032660, 18.418140, -88.036140, 18.168120, -87.885120, 18.166710, -87.743110, 18.169600, -85.490870, 18.197550, -86.918150, 24.986800, -82.895810, 23.950120, -79.844250, 24.542700, -79.202930, 28.054830, -61.120620, 24.567970, -44.936670, 10.184090, -60.017524, 11.606745, -60.625771, 10.148200, -60.969631, 9.869484, -61.183882, 9.856455, -61.326717, 9.879908, -61.498647, 9.942442, -61.689092, 9.958074, -61.913924, 9.968495, -62.125530, 10.017989, -61.898053, 10.556716, -61.744639, 10.917944, -61.784366, 11.703881];
  var travelMode;
  var distIndex;
  var waypoints = new Array();
  var addresses = new Array();
  var labels = new Array();
  var addr = new Array();
  var wpActive = new Array();
  var addressRequests = 0;
  var addressProcessing = false;
  var requestNum = 0;
  var currQueueNum = 0;
  var wayArr;
  var legsTmp;
  var durations;
  var legs;
  var dur;
  var visited;
  var currPath;
  var bestPath;
  var bestTrip;
  var nextSet;
  var numActive;
  var costForward;
  var costBackward;
  var improved = false;
  var chunkNode;
  var okChunkNode;
  var numDirectionsComputed = 0;
  var numDirectionsNeeded = 0;
  var cachedDirections = false;
  var requestLimitWait = 1000;
  var fakeDirResult; // Object used to store travel info like travel mode etc. Needed for route renderer.

  var onSolveCallback = function() {};
  var onProgressCallback = null;
  var originalOnFatalErrorCallback = function(tsp, errMsg) {
    alert("Request failed: " + errMsg);
  }
  var onFatalErrorCallback = originalOnFatalErrorCallback;
  var doNotContinue = false;
  var onLoadListener = null;
  var onFatalErrorListener = null;

  var directionunits;

  /** Computes greedy (nearest-neighbor solution to the TSP)
   */
  function tspGreedy(mode) {
    var curr = 0;
    var currDist = 0;
    var numSteps = numActive - 1;
    var lastNode = 0;
    var numToVisit = numActive;
    if (mode == 1) {
      numSteps = numActive - 2;
      lastNode = numActive - 1;
      numToVisit = numActive - 1;
    }
    for (var step = 0; step < numSteps; ++step) {
      visited[curr] = true;
      bestPath[step] = curr;
      var nearest = maxTripSentry;
      var nearI = -1;
      for (var next = 1; next < numToVisit; ++next) {
        if (!visited[next] && dur[curr][next] < nearest) {
          nearest = dur[curr][next];
          nearI = next;
        }
      }
      currDist += dur[curr][nearI];
      curr = nearI;
    }
    if (mode == 1) bestPath[numSteps] = lastNode;
    else bestPath[numSteps] = curr;
    currDist += dur[curr][lastNode];
    bestTrip = currDist;
  }

  /** Returns the cost of moving along the current solution path offset
   *  given by a to b. Handles moving both forward and backward.
   */
  function cost(a, b) {
    if (a <= b) {
      return costForward[b] - costForward[a];
    } else {
      return costBackward[b] - costBackward[a];
    }
  }

  /** Returns the cost of the given 3-opt variation of the current solution.
   */
  function costPerm(a, b, c, d, e, f) {
    var A = currPath[a];
    var B = currPath[b];
    var C = currPath[c];
    var D = currPath[d];
    var E = currPath[e];
    var F = currPath[f];
    var g = currPath.length - 1;

    var ret = cost(0, a) + dur[A][B] + cost(b, c) + dur[C][D] + cost(d, e) + dur[E][F] + cost(f, g);
    return ret;
  }

  /** Update the datastructures necessary for cost(a,b) and costPerm to work
   *  efficiently.
   */
  function updateCosts() {
    costForward = new Array(currPath.length);
    costBackward = new Array(currPath.length);

    costForward[0] = 0.0;
    for (var i = 1; i < currPath.length; ++i) {
      costForward[i] = costForward[i - 1] + dur[currPath[i - 1]][currPath[i]];
    }
    bestTrip = costForward[currPath.length - 1];
    console.log("new bestTrip: " + bestTrip);
    costBackward[currPath.length - 1] = 0.0;
    for (var i = currPath.length - 2; i >= 0; --i) {
      costBackward[i] = costBackward[i + 1] + dur[currPath[i + 1]][currPath[i]];
    }
  }

  /** Update the current solution with the given 3-opt move.
   */
  function updatePerm(a, b, c, d, e, f) {
    improved = true;
    var nextPath = new Array(currPath.length);
    for (var i = 0; i < currPath.length; ++i) nextPath[i] = currPath[i];
    var offset = a + 1;
    nextPath[offset++] = currPath[b];
    if (b < c) {
      for (var i = b + 1; i <= c; ++i) {
        nextPath[offset++] = currPath[i];
      }
    } else {
      for (var i = b - 1; i >= c; --i) {
        nextPath[offset++] = currPath[i];
      }
    }
    nextPath[offset++] = currPath[d];
    if (d < e) {
      for (var i = d + 1; i <= e; ++i) {
        nextPath[offset++] = currPath[i];
      }
    } else {
      for (var i = d - 1; i >= e; --i) {
        nextPath[offset++] = currPath[i];
      }
    }
    nextPath[offset++] = currPath[f];
    currPath = nextPath;

    updateCosts();
  }

  /** Uses the 3-opt algorithm to find a good solution to the TSP.
   */
  function tspK3(mode) {
    // tspGreedy(mode);
    currPath = new Array(bestPath.length);
    for (var i = 0; i < bestPath.length; ++i) currPath[i] = bestPath[i];

    updateCosts();
    improved = true;
    var epsilon = 1e-3; // one msec
    while (improved) {
      console.log("bestTrip: " + bestTrip);
      improved = false;
      for (var i = 0; i < currPath.length - 3; ++i) {
        for (var j = i + 1; j < currPath.length - 2; ++j) {
          for (var k = j + 1; k < currPath.length - 1; ++k) {
            if (costPerm(i, i + 1, j, k, j + 1, k + 1) + epsilon < bestTrip)
              updatePerm(i, i + 1, j, k, j + 1, k + 1);
            if (costPerm(i, j, i + 1, j + 1, k, k + 1) + epsilon < bestTrip)
              updatePerm(i, j, i + 1, j + 1, k, k + 1);
            if (costPerm(i, j, i + 1, k, j + 1, k + 1) + epsilon < bestTrip)
              updatePerm(i, j, i + 1, k, j + 1, k + 1);
            if (costPerm(i, j + 1, k, i + 1, j, k + 1) + epsilon < bestTrip)
              updatePerm(i, j + 1, k, i + 1, j, k + 1);
            if (costPerm(i, j + 1, k, j, i + 1, k + 1) + epsilon < bestTrip)
              updatePerm(i, j + 1, k, j, i + 1, k + 1);
            if (costPerm(i, k, j + 1, i + 1, j, k + 1) + epsilon < bestTrip)
              updatePerm(i, k, j + 1, i + 1, j, k + 1);
            if (costPerm(i, k, j + 1, j, i + 1, k + 1) + epsilon < bestTrip)
              updatePerm(i, k, j + 1, j, i + 1, k + 1);
          }
        }
      }
    }
    for (var i = 0; i < bestPath.length; ++i) bestPath[i] = currPath[i];
  }

  /* Computes a near-optimal solution to the TSP problem, 
   * using Ant Colony Optimization and local optimization
   * in the form of k2-opting each candidate route.
   * Run time is O(numWaves * numAnts * numActive ^ 2) for ACO
   * and O(numWaves * numAnts * numActive ^ 3) for rewiring?
   * 
   * if mode is 1, we start at node 0 and end at node numActive-1.
   */
  function tspAntColonyK2(mode) {
    var alfa = 0.1; // The importance of the previous trails
    var beta = 2.0; // The importance of the durations
    var rho = 0.1; // The decay rate of the pheromone trails
    var asymptoteFactor = 0.9; // The sharpness of the reward as the solutions approach the best solution
    var pher = new Array();
    var nextPher = new Array();
    var prob = new Array();
    var numAnts = 20;
    var numWaves = 20;
    for (var i = 0; i < numActive; ++i) {
      pher[i] = new Array();
      nextPher[i] = new Array();
    }
    for (var i = 0; i < numActive; ++i) {
      for (var j = 0; j < numActive; ++j) {
        pher[i][j] = 1;
        nextPher[i][j] = 0.0;
      }
    }

    var lastNode = 0;
    var startNode = 0;
    var numSteps = numActive - 1;
    var numValidDests = numActive;
    if (mode == 1) {
      lastNode = numActive - 1;
      numSteps = numActive - 2;
      numValidDests = numActive - 1;
    }
    for (var wave = 0; wave < numWaves; ++wave) {
      for (var ant = 0; ant < numAnts; ++ant) {
        var curr = startNode;
        var currDist = 0;
        for (var i = 0; i < numActive; ++i) {
          visited[i] = false;
        }
        currPath[0] = curr;
        for (var step = 0; step < numSteps; ++step) {
          visited[curr] = true;
          var cumProb = 0.0;
          for (var next = 1; next < numValidDests; ++next) {
            if (!visited[next]) {
              prob[next] = Math.pow(pher[curr][next], alfa) *
                Math.pow(dur[curr][next], 0.0 - beta);
              cumProb += prob[next];
            }
          }
          var guess = Math.random() * cumProb;
          var nextI = -1;
          for (var next = 1; next < numValidDests; ++next) {
            if (!visited[next]) {
              nextI = next;
              guess -= prob[next];
              if (guess < 0) {
                nextI = next;
                break;
              }
            }
          }
          currDist += dur[curr][nextI];
          currPath[step + 1] = nextI;
          curr = nextI;
        }
        currPath[numSteps + 1] = lastNode;
        currDist += dur[curr][lastNode];

        // k2-rewire:
        var lastStep = numActive;
        if (mode == 1) {
          lastStep = numActive - 1;
        }
        var changed = true;
        var i = 0;
        while (changed) {
          changed = false;
          for (; i < lastStep - 2 && !changed; ++i) {
            var cost = dur[currPath[i + 1]][currPath[i + 2]];
            var revCost = dur[currPath[i + 2]][currPath[i + 1]];
            var iCost = dur[currPath[i]][currPath[i + 1]];
            var tmp, nowCost, newCost;
            for (var j = i + 2; j < lastStep && !changed; ++j) {
              nowCost = cost + iCost + dur[currPath[j]][currPath[j + 1]];
              newCost = revCost + dur[currPath[i]][currPath[j]] + dur[currPath[i + 1]][currPath[j + 1]];
              if (nowCost > newCost + 1e-3) {
                currDist += newCost - nowCost;
                // Reverse the detached road segment.
                for (var k = 0; k < Math.floor((j - i) / 2); ++k) {
                  tmp = currPath[i + 1 + k];
                  currPath[i + 1 + k] = currPath[j - k];
                  currPath[j - k] = tmp;
                }
                changed = true;
                --i;
              }
              cost += dur[currPath[j]][currPath[j + 1]];
              revCost += dur[currPath[j + 1]][currPath[j]];
            }
          }
        }

        if (currDist < bestTrip) {
          bestPath = currPath;
          bestTrip = currDist;
        }
        for (var i = 0; i <= numSteps; ++i) {
          nextPher[currPath[i]][currPath[i + 1]] += (bestTrip - asymptoteFactor * bestTrip) / (numAnts * (currDist - asymptoteFactor * bestTrip));
        }
      }
      for (var i = 0; i < numActive; ++i) {
        for (var j = 0; j < numActive; ++j) {
          pher[i][j] = pher[i][j] * (1.0 - rho) + rho * nextPher[i][j];
          nextPher[i][j] = 0.0;
        }
      }
    }
  }

  /* Returns the optimal solution to the TSP problem.
   * Run-time is O((numActive-1)!).
   * Prerequisites: 
   * - numActive contains the number of locations
   * - dur[i][j] contains weight of edge from node i to node j
   * - visited[i] should be false for all nodes
   * - bestTrip is set to a very high number
   *
   * If mode is 1, it will return the optimal solution to the related
   * problem of finding a path from node 0 to node numActive - 1, visiting
   * the in-between nodes in the best order.
   */
  function tspBruteForce(mode, currNode, currLen, currStep) {
    // Set mode parameters:
    var numSteps = numActive;
    var lastNode = 0;
    var numToVisit = numActive;
    if (mode == 1) {
      numSteps = numActive - 1;
      lastNode = numActive - 1;
      numToVisit = numActive - 1;
    }

    // If this route is promising:
    if (currLen + dur[currNode][lastNode] < bestTrip) {

      // If this is the last node:
      if (currStep == numSteps) {
        currLen += dur[currNode][lastNode];
        currPath[currStep] = lastNode;
        bestTrip = currLen;
        for (var i = 0; i <= numSteps; ++i) {
          bestPath[i] = currPath[i];
        }
      } else {

        // Try all possible routes:
        for (var i = 1; i < numToVisit; ++i) {
          if (!visited[i]) {
            visited[i] = true;
            currPath[currStep] = i;
            tspBruteForce(mode, i, currLen + dur[currNode][i], currStep + 1);
            visited[i] = false;
          }
        }
      }
    }
  }

  /* Finds the next integer that has num bits set to 1.
   */
  function nextSetOf(num) {
    var count = 0;
    var ret = 0;
    for (var i = 0; i < numActive; ++i) {
      count += nextSet[i];
    }
    if (count < num) {
      for (var i = 0; i < num; ++i) {
        nextSet[i] = 1;
      }
      for (var i = num; i < numActive; ++i) {
        nextSet[i] = 0;
      }
    } else {
      // Find first 1
      var firstOne = -1;
      for (var i = 0; i < numActive; ++i) {
        if (nextSet[i]) {
          firstOne = i;
          break;
        }
      }
      // Find first 0 greater than firstOne
      var firstZero = -1;
      for (var i = firstOne + 1; i < numActive; ++i) {
        if (!nextSet[i]) {
          firstZero = i;
          break;
        }
      }
      if (firstZero < 0) {
        return -1;
      }
      // Increment the first zero with ones behind it
      nextSet[firstZero] = 1;
      // Set the part behind that one to its lowest possible value
      for (var i = 0; i < firstZero - firstOne - 1; ++i) {
        nextSet[i] = 1;
      }
      for (var i = firstZero - firstOne - 1; i < firstZero; ++i) {
        nextSet[i] = 0;
      }
    }
    // Return the index for this set
    for (var i = 0; i < numActive; ++i) {
      ret += (nextSet[i] << i);
    }
    return ret;
  }

  /* Solves the TSP problem to optimality. Memory requirement is
   * O(numActive * 2^numActive)
   */
  function tspDynamic(mode) {
    var numCombos = 1 << numActive;
    var C = new Array();
    var parent = new Array();
    for (var i = 0; i < numCombos; ++i) {
      C[i] = new Array();
      parent[i] = new Array();
      for (var j = 0; j < numActive; ++j) {
        C[i][j] = 0.0;
        parent[i][j] = 0;
      }
    }
    for (var k = 1; k < numActive; ++k) {
      var index = 1 + (1 << k);
      C[index][k] = dur[0][k];
    }
    for (var s = 3; s <= numActive; ++s) {
      for (var i = 0; i < numActive; ++i) {
        nextSet[i] = 0;
      }
      var index = nextSetOf(s);
      while (index >= 0) {
        for (var k = 1; k < numActive; ++k) {
          if (nextSet[k]) {
            var prevIndex = index - (1 << k);
            C[index][k] = maxTripSentry;
            for (var m = 1; m < numActive; ++m) {
              if (nextSet[m] && m != k) {
                if (C[prevIndex][m] + dur[m][k] < C[index][k]) {
                  C[index][k] = C[prevIndex][m] + dur[m][k];
                  parent[index][k] = m;
                }
              }
            }
          }
        }
        index = nextSetOf(s);
      }
    }
    for (var i = 0; i < numActive; ++i) {
      bestPath[i] = 0;
    }
    var index = (1 << numActive) - 1;
    if (mode == 0) {
      var currNode = -1;
      bestPath[numActive] = 0;
      for (var i = 1; i < numActive; ++i) {
        if (C[index][i] + dur[i][0] < bestTrip) {
          bestTrip = C[index][i] + dur[i][0];
          currNode = i;
        }
      }
      bestPath[numActive - 1] = currNode;
    } else {
      var currNode = numActive - 1;
      bestPath[numActive - 1] = numActive - 1;
      bestTrip = C[index][numActive - 1];
    }
    for (var i = numActive - 1; i > 0; --i) {
      currNode = parent[index][currNode];
      index -= (1 << bestPath[i]);
      bestPath[i - 1] = currNode;
    }
  }

  function makeLatLng(latLng) {
    return (latLng.toString().substr(1, latLng.toString().length - 2));
  }

  function makeDirWp(latLng, address) {
    return ({
      location: latLng,
      stopover: true
    });
  }

  function getWayArr(curr) {
    var nextAbove = -1;
    for (var i = curr + 1; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        if (nextAbove == -1) {
          nextAbove = i;
        } else {
          wayArr.push(makeDirWp(waypoints[i], addresses[i]));
          wayArr.push(makeDirWp(waypoints[curr], addresses[curr]));
        }
      }
    }
    if (nextAbove != -1) {
      wayArr.push(makeDirWp(waypoints[nextAbove], addresses[nextAbove]));
      getWayArr(nextAbove);
      wayArr.push(makeDirWp(waypoints[curr], addresses[curr]));
    }
  }

  function getDistTable(curr, currInd) {
    var nextAbove = -1;
    var index = currInd;
    for (var i = curr + 1; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        index++;
        if (nextAbove == -1) {
          nextAbove = i;
        } else {
          dur[currInd][index] = durations[distIndex++];
          dur[index][currInd] = durations[distIndex++];
        }
      }
    }
    if (nextAbove != -1) {
      dur[currInd][currInd + 1] = durations[distIndex++];
      getDistTable(nextAbove, currInd + 1);
      dur[currInd + 1][currInd] = durations[distIndex++];
    }
  }

  function directions(mode) {
    if (cachedDirections) {
      // Bypass Google directions lookup if we already have the duration matrix.
      doTsp(mode);
    }
    legsTmp = new Array();
    durations = new Array();
    chunkNode = 0;
    okChunkNode = 0;
    if (mode == 2) {
      // No optimization
      setTrivialBestPath();
      doPredefinedRoute();
      return;
    }
    wayArr = new Array();
    numActive = 0;
    numDirectionsComputed = 0;
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) ++numActive;
    }
    numDirectionsNeeded = numActive * numActive;

    if (numActive > maxTspSize) {
      alert("Too many locations! You have " + numActive + ", but max limit is " + maxTspSize);
    } else {
      if (typeof onProgressCallback == 'function') {
        onProgressCallback(tsp);
      }

      getDurationsFromGoogle(mode);
    }
  }

  function isInsidePolygon(latLng, bounds) {
    var inside = false;
    var j;
    for (var i = 0, j = bounds.length - 1; i < bounds.length; j = i++) {
      if (((bounds[i].lat() > latLng.lat()) != (bounds[j].lat() > latLng.lat())) &&
        (latLng.lng() < (bounds[j].lng()-bounds[i].lng()) * (latLng.lat()-bounds[i].lat()) / (bounds[j].lat()-bounds[i].lat()) + bounds[i].lng())) {
        inside = !inside;
      }
    }
    return inside;
  }

  /* lngLats is raw interleaved array, lng, lat-style */
  function toLatLngArr(lngLats) {
    var arr = new Array();
    for (var i = 0; i < lngLats.length; i+=2) {
      arr.push(new google.maps.LatLng(lngLats[i+1], lngLats[i]));
    }
    return arr;
  }

  function isAllIn(boundsInterleaved) {
    var bounds = toLatLngArr(boundsInterleaved);
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        if (!isInsidePolygon(waypoints[i], bounds)) return false;
      }
    }
    return true;
  }

  function getDurationsFromOsrm(mode, continent) {
    wayArr = new Array();
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        wayArr.push(makeDirWp(waypoints[i], addresses[i]));
      }
    }
    var lngLatStr = ""; // Yes, really
    for (var i = 0; i < wayArr.length; i++) {
      lngLatStr += wayArr[i].location.lng() + "," + wayArr[i].location.lat();
      if (i != wayArr.length - 1) {
        lngLatStr += ";";
      }
    }
    makeArrays();
    jQuery.ajax({
      url: 'backend.php?q=' + lngLatStr + '&c=' + continent,
      type: 'GET',
      timeout: 30000,
      success: function(data) {
        for (var i = 0; i < data.durations.length; i++) {
          for (var j = 0; j < data.durations[i].length; j++) {
            dur[i][j] = data.durations[i][j];
          }
        }
        doTsp(mode);
      },
      error: function(data) {
        getDurationsFromGoogle(mode);
      }
    });
  }

  function getDurationsFromGoogle(mode) {
    wayArr = new Array();
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        wayArr.push(makeDirWp(waypoints[i], addresses[i]));
        getWayArr(i);
        break;
      }
    }
    getDurationsFromGoogleRec(mode);
  }
  
  function getDurationsFromGoogleRec(mode) {
    chunkNode = okChunkNode;
    if (chunkNode < wayArr.length) {
      var wayArrChunk = new Array();
      for (var i = 0; i < maxSize && i + chunkNode < wayArr.length; ++i) {
        wayArrChunk.push(wayArr[chunkNode + i]);
      }
      var origin;
      var destination;
      origin = wayArrChunk[0].location;
      destination = wayArrChunk[wayArrChunk.length - 1].location;
      var wayArrChunk2 = new Array();
      for (var i = 1; i < wayArrChunk.length - 1; i++) {
        wayArrChunk2[i - 1] = wayArrChunk[i];
      }
      chunkNode += maxSize;
      if (chunkNode < wayArr.length - 1) {
        chunkNode--;
      }

      var myGebDirections = new google.maps.DirectionsService();

      myGebDirections.route({
          origin: origin,
          destination: destination,
          waypoints: wayArrChunk2,
          avoidHighways: avoidHighways,
          avoidTolls: avoidTolls,
          unitSystem: directionunits,
          travelMode: travelMode
        },
        function(directionsResult, directionsStatus) {
          if (directionsStatus == google.maps.DirectionsStatus.OK) {
            requestLimitWait = 1000;
            // Save legs and durations
            fakeDirResult = directionsResult;
            for (var i = 0; i < directionsResult.routes[0].legs.length; ++i) {
              ++numDirectionsComputed;
              durations.push(directionsResult.routes[0].legs[i].duration.value);
            }
            if (typeof onProgressCallback == 'function') {
              onProgressCallback(tsp);
            }
            okChunkNode = chunkNode;
            getDurationsFromGoogleRec(mode);
          } else if (directionsStatus == google.maps.DirectionsStatus.OVER_QUERY_LIMIT) {
            requestLimitWait = Math.min(2 * requestLimitWait, 30000);
            setTimeout(function() {
              getDurationsFromGoogleRec(mode)
            }, requestLimitWait);
          } else if (directionsStatus == google.maps.DirectionsStatus.NOT_FOUND) {
            var failedAddrArr = new Array();
            for (var i = 0; i < directionsResult.geocoded_waypoints.length; ++i) {
              if (google.maps.GeocoderStatus.ZERO_RESULTS == directionsResult.geocoded_waypoints[i].geocoder_status) {
                var wpInd = i - 1;
                var addr;
                if (wpInd < 0) {
                  addr = directionsResult.request.origin;
                } else if (wpInd >= directionsResult.request.waypoints.length) {
                  addr = directionsResult.request.destination;
                } else {
                  addr = directionsResult.request.waypoints[wpInd].location;
                }
                if (failedAddrArr.indexOf(addr) == -1) {
                  failedAddrArr.push(addr);
                }
              }
            }
            var errorMsg = "Please check the following addresses: ";
            for (var i = 0; i < failedAddrArr.length; ++i) {
              errorMsg += failedAddrArr[i];
              if (i < failedAddrArr.length - 1) {
                errorMsg += ", ";
              }
            }
            alert(errorMsg);
          } else if (directionsStatus == google.maps.DirectionsStatus.ZERO_RESULTS) {
            alert("Could not find any route between the given points. This is usually caused by destinations that are not reachable by road. Please check that all your destinations are near roads and try again.");
            doNotContinue = true;
          } else {
            var errorMsg = directionsStatus;
            var doNotContinue = true;
            alert("Request failed: " + errorMsg);
          }
        }
      );
    } else {
      convertGoogleDurations(mode);
    }
  }

  function convertGoogleDurations(mode) {
    // Get durations into 2-d arrays:
    makeArrays();
    distIndex = 0;
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        getDistTable(i, 0);
        break;
      }
    }

    doTsp(mode);
  }

  function makeArrays() {
    dur = new Array();
    numActive = 0;
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        dur.push(new Array());
        addr[numActive] = addresses[i];
        numActive++;
      }
    }
    for (var i = 0; i < numActive; ++i) {
      dur[i][i] = 0;
    }
  }

  function doTsp(mode) {
    // Calculate shortest roundtrip using durations matrix only:
    visited = new Array();
    for (var i = 0; i < numActive; ++i) {
      visited[i] = false;
    }
    currPath = new Array();
    bestPath = new Array();
    nextSet = new Array();
    bestTrip = maxTripSentry;
    visited[0] = true;
    currPath[0] = 0;
    cachedDirections = true;
    if (numActive <= maxTspBF + mode) {
      tspBruteForce(mode, 0, 0, 1);
    } else if (numActive <= maxTspDynamic + mode) {
      tspDynamic(mode);
    } else {
      tspAntColonyK2(mode);
      tspK3(mode);
    }

    // Fill in the full legs data for the optimal solution found
    okChunkNode = 0;
    legsTmp = new Array();
    durations = new Array();
    fillBestPathDirections(function() { fillLegsAndDurations(); });
  }

  function setTrivialBestPath() {
    // Set trivial best path 0, 1, 2 etc.
    bestPath = new Array();
    var count = 0;
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        bestPath.push(count++);
      }
    }
  }

  function doPredefinedRoute() {
    numDirectionsComputed = 0;
    numActive = 0;
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) ++numActive;
    }
    numDirectionsNeeded = numActive - 1;
    if (typeof onProgressCallback == 'function') {
      onProgressCallback(tsp);
    }

    okChunkNode = 0;
    legsTmp = new Array();
    durations = new Array();
    fillBestPathDirections(function() { fillLegsAndDurations(); });
  }

  function fillBestPathDirections(cb) {
    chunkNode = okChunkNode;
    var wpIndices = new Array();
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        wpIndices.push(i);
      }
    }
    if (chunkNode >= bestPath.length - 1) {
      cb();
      return;
    }
    var wayArrChunk = new Array();
    var wayArrChunk2 = new Array();
    var destination;
    var origin;

    for (; chunkNode < bestPath.length && wayArrChunk.length < maxSize; chunkNode++) {
      wayArrChunk.push(makeDirWp(waypoints[wpIndices[bestPath[chunkNode]]], addresses[wpIndices[bestPath[chunkNode]]]));
    }
    origin = wayArrChunk[0].location;
    destination = wayArrChunk[wayArrChunk.length - 1].location;
    for (var i = 1; i < wayArrChunk.length - 1; i++) {
      wayArrChunk2.push(wayArrChunk[i]);
    }
    var myGebDirections = new google.maps.DirectionsService();
    myGebDirections.route({
        origin: origin,
        destination: destination,
        waypoints: wayArrChunk2,
        avoidHighways: avoidHighways,
        avoidTolls: avoidTolls,
        unitSystem: directionunits,
        travelMode: travelMode
      },
      function(directionsResult, directionsStatus) {
        if (directionsStatus == google.maps.DirectionsStatus.OK) {
          requestLimitWait = 1000;
          //alert("Request completed!");
          // Save legs and durations
          fakeDirResult = directionsResult;
          for (var i = 0; i < directionsResult.routes[0].legs.length; ++i) {
            ++numDirectionsComputed;
            legsTmp.push(directionsResult.routes[0].legs[i]);
            durations.push(directionsResult.routes[0].legs[i].duration.value);
          }
          if (typeof onProgressCallback == 'function') {
            onProgressCallback(tsp);
          }
          okChunkNode = chunkNode - 1;
          fillBestPathDirections(cb);
        } else if (directionsStatus == google.maps.DirectionsStatus.OVER_QUERY_LIMIT) {
          requestLimitWait *= 2;
          setTimeout(function() {
            fillBestPathDirections(cb)
          }, requestLimitWait);
        } else if (directionsStatus == google.maps.DirectionsStatus.NOT_FOUND) {
          var failedAddrArr = new Array();
          for (var i = 0; i < directionsResult.geocoded_waypoints.length; ++i) {
            if (google.maps.GeocoderStatus.ZERO_RESULTS == directionsResult.geocoded_waypoints[i].geocoder_status) {
              var wpInd = i - 1;
              var addr;
              if (wpInd < 0) {
                addr = directionsResult.request.origin;
              } else if (wpInd >= directionsResult.request.waypoints.length) {
                addr = directionsResult.request.destination;
              } else {
                addr = directionsResult.request.waypoints[wpInd].location;
              }
              if (failedAddrArr.indexOf(addr) == -1) {
                failedAddrArr.push(addr);
              }
            }
          }
          var errorMsg = "Please check the following addresses: ";
          for (var i = 0; i < failedAddrArr.length; ++i) {
            errorMsg += failedAddrArr[i];
            if (i < failedAddrArr.length - 1) {
              errorMsg += ", ";
            }
          }
          alert(errorMsg);
        } else if (directionsStatus == google.maps.DirectionsStatus.ZERO_RESULTS) {
          alert("Could not find any route between the given points. This is usually caused by destinations that are not reachable by road. Please check that all your destinations are near roads and try again.");
          doNotContinue = true;
        } else {
          var errorMsg = directionsStatus;
          var doNotContinue = true;
          alert("Request failed: " + errorMsg);
        }
      }
    );
  }

  function fillLegsAndDurations(mode) {
    distIndex = 0;
    legs = new Array();
    dur = new Array();
    numActive = 0;
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        legs.push(new Array());
        dur.push(new Array());
        addr[numActive] = addresses[i];
        numActive++;
      }
    }
    for (var i = 0; i < numActive; ++i) {
      legs[i][i] = null;
      dur[i][i] = 0;
    }
    for (var i = 0; i < legsTmp.length; ++i) {
      legs[bestPath[i]][bestPath[i + 1]] = legsTmp[i];
      dur[bestPath[i]][bestPath[i + 1]] = durations[i];
    }

    prepareSolution();
  }

  function prepareSolution() {
    var wpIndices = new Array();
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i]) {
        wpIndices.push(i);
      }
    }
    var bestPathLatLngStr = "";
    var directionsResultLegs = new Array();
    var directionsResultRoutes = new Array();
    var directionsResultOverview = new Array();
    var directionsResultBounds = new google.maps.LatLngBounds();
    for (var i = 1; i < bestPath.length; ++i) {
      directionsResultLegs.push(legs[bestPath[i - 1]][bestPath[i]]);
    }
    for (var i = 0; i < bestPath.length; ++i) {
      bestPathLatLngStr += makeLatLng(waypoints[wpIndices[bestPath[i]]]) + "\n";
      directionsResultBounds.extend(waypoints[wpIndices[bestPath[i]]]);
      directionsResultOverview.push(waypoints[wpIndices[bestPath[i]]]);
    }
    directionsResultRoutes.push({
      legs: directionsResultLegs,
      bounds: directionsResultBounds,
      copyrights: "Map data 2012 Google",
      overview_path: directionsResultOverview,
      warnings: new Array(),
    });
    gebDirectionsResult = fakeDirResult;
    gebDirectionsResult.routes = directionsResultRoutes;

    if (onFatalErrorListener)
      google.maps.event.removeListener(onFatalErrorListener);
    onFatalErrorListener = google.maps.event.addListener(gebDirectionsService, 'error', onFatalErrorCallback);

    if (typeof onSolveCallback == 'function') {
      onSolveCallback(tsp);
    }
  }

  function reverseSolution() {
    for (var i = 0; i < bestPath.length / 2; ++i) {
      var tmp = bestPath[bestPath.length - 1 - i];
      bestPath[bestPath.length - 1 - i] = bestPath[i];
      bestPath[i] = tmp;
    }
    doPredefinedRoute();
  }

  function reorderSolution(newOrder) {
    var newBestPath = new Array(bestPath.length);
    for (var i = 0; i < bestPath.length; ++i) {
      newBestPath[i] = bestPath[newOrder[i]];
    }
    bestPath = newBestPath;
    doPredefinedRoute();
  }

  function removeStop(number) {
    var newBestPath = new Array(bestPath.length - 1);
    for (var i = 0; i < bestPath.length; ++i) {
      if (i != number) {
        newBestPath[i - (i > number ? 1 : 0)] = bestPath[i];
      }
    }
    bestPath = newBestPath;
    doPredefinedRoute();
  }

  function addGeoAndAddressWithLabel(latLng, address, label, callback) {
    var freeInd = -1;
    for (var i = 0; i < waypoints.length; ++i) {
      if (!wpActive[i]) {
        freeInd = i;
        break;
      }
    }
    // Use addresses as labels, if not explicitly set
    if (label == null) {
      label = address;
    }
    if (freeInd == -1) {
      if (waypoints.length < maxTspSize) {
        waypoints.push(latLng);
        labels.push(label);
        addresses.push(address);
        wpActive.push(true);
        freeInd = waypoints.length - 1;
      } else {
        if (typeof callback == 'function')
          callback(address, latLng);
        return (-1);
      }
    } else {
      waypoints[freeInd] = latLng;
      labels[freeInd] = label;
      addresses[freeInd] = address;
      wpActive[freeInd] = true;
    }
    if (typeof callback == 'function')
      callback(address, latLng);
    return (freeInd);
  }

  function addWaypoint(latLng, label, callback) {
    return addGeoAndAddressWithLabel(latLng, null, label, callback);
  }

  function addAddress(address, label, fullAddress, callback) {
    addressProcessing = true;
    gebGeocoder.geocode({
      address: address
    }, function(results, status) {
      if (status == google.maps.GeocoderStatus.OK) {
        addressProcessing = false;
        --addressRequests;
        ++currQueueNum;
        if (results.length >= 1) {
          var latLng = results[0].geometry.location;
          fullAddress = fullAddress.replace("'", "");
          fullAddress = fullAddress.replace("\"", "");
          addGeoAndAddressWithLabel(latLng, fullAddress, label, callback);
        }
      } else if (status == google.maps.GeocoderStatus.OVER_QUERY_LIMIT) {
        setTimeout(function() {
          addAddress(address, label, fullAddress, callback)
        }, 100);
      } else if (status == google.maps.GeocoderStatus.ZERO_RESULTS) {
        // Try less specific address
        if (address.indexOf(",") != -1) {
          address = address.substr(address.indexOf(",")+1);
          addAddress(address, label, fullAddress, callback)
        } else if (address.indexOf(" ") != -1) {
          address = address.substr(address.indexOf(" ")+1);
          addAddress(address, label, fullAddress, callback)
        } else {
          --addressRequests;
          alert("Could not find address: " + address + ". Try removing the town or postal code part of the address");
          ++currQueueNum;
          addressProcessing = false;
          if (typeof(callback) == 'function')
            callback(address);
        }
      } else {
        --addressRequests;
        alert("Failed to geocode address: " + address + ". Reason: " + status);
        ++currQueueNum;
        addressProcessing = false;
        if (typeof(callback) == 'function')
          callback(address);
      }
    });
  }

  function swapWaypoints(i, j) {
    var tmpAddr = addresses[j];
    var tmpWaypoint = waypoints[j];
    var tmpActive = wpActive[j];
    var tmpLabel = labels[j];
    addresses[j] = addresses[i];
    addresses[i] = tmpAddr;
    waypoints[j] = waypoints[i];
    waypoints[i] = tmpWaypoint;
    wpActive[j] = wpActive[i];
    wpActive[i] = tmpActive;
    labels[j] = labels[i];
    labels[i] = tmpLabel;
  }

  BpTspSolver.prototype.startOver = function() {
    waypoints = new Array();
    addresses = new Array();
    labels = new Array();
    addr = new Array();
    wpActive = new Array();
    wayArr = new Array();
    legsTmp = new Array();
    durations = new Array();
    legs = new Array();
    dur = new Array();
    visited = new Array();
    currPath = new Array();
    bestPath = new Array();
    bestTrip = new Array();
    nextSet = new Array();
    travelMode = google.maps.DirectionsTravelMode.DRIVING;
    numActive = 0;
    chunkNode = 0;
    okChunkNode = 0;
    addressRequests = 0;
    addressProcessing = false;
    requestNum = 0;
    currQueueNum = 0;
    cachedDirections = false;
    onSolveCallback = function() {};
    onProgressCallback = null;
    doNotContinue = false;
    directionunits = google.maps.UnitSystem.METRIC;
  }

  /* end (edited) OptiMap code */
  /* start public interface */

  function BpTspSolver(map, panel, onFatalError) {
    if (tsp) {
      alert('You can only create one BpTspSolver at a time.');
      return;
    }

    gebMap = map;
    directionsPanel = panel;
    gebGeocoder = new google.maps.Geocoder();
    gebDirectionsService = new google.maps.DirectionsService();
    onFatalErrorCallback = onFatalError; // only for fatal errors, not geocoding errors
    tsp = this;
  }

  BpTspSolver.prototype.addAddressWithLabel = function(address, label, callback) {
    ++addressRequests;
    ++requestNum;
    tsp.addAddressAgain(address, label, callback, requestNum - 1);
  }

  BpTspSolver.prototype.addAddress = function(address, callback) {
    tsp.addAddressWithLabel(address, null, callback);
  };

  BpTspSolver.prototype.addAddressAgain = function(address, label, callback, queueNum) {
    if (addressProcessing || queueNum > currQueueNum) {
      setTimeout(function() {
        tsp.addAddressAgain(address, label, callback, queueNum)
      }, 100);
      return;
    }
    addAddress(address, label, address, callback);
  };

  BpTspSolver.prototype.addWaypointWithLabel = function(latLng, label, callback) {
    ++requestNum;
    tsp.addWaypointAgain(latLng, label, callback, requestNum - 1);
  };

  BpTspSolver.prototype.addWaypoint = function(latLng, callback) {
    tsp.addWaypointWithLabel(latLng, null, callback);
  };

  BpTspSolver.prototype.addGeoAndAddressWithLabel = function(latLng, addr, label, callback) {
    addGeoAndAddressWithLabel(latLng, addr, label, callback);
  };

  BpTspSolver.prototype.addWaypointAgain = function(latLng, label, callback, queueNum) {
    if (addressProcessing || queueNum > currQueueNum) {
      setTimeout(function() {
        tsp.addWaypointAgain(latLng, label, callback, queueNum)
      }, 100);
      return;
    }
    addWaypoint(latLng, label);
    ++currQueueNum;
    if (typeof(callback) == 'function') {
      callback(latLng);
    }
  }

  BpTspSolver.prototype.getWaypoints = function() {
    var wp = [];
    for (var i = 0; i < waypoints.length; i++) {
      if (wpActive[i]) {
        wp.push(waypoints[i]);
      }
    }
    return wp;
  };

  BpTspSolver.prototype.getAddresses = function() {
    var addrs = [];
    for (var i = 0; i < addresses.length; i++) {
      if (wpActive[i])
        addrs.push(addresses[i]);
    }
    return addrs;
  };

  BpTspSolver.prototype.getLabels = function() {
    var labs = [];
    for (var i = 0; i < labels.length; i++) {
      if (wpActive[i])
        labs.push(labels[i]);
    }
    return labs;
  };

  BpTspSolver.prototype.setLabel = function(latLng, label) {
    for (var i = 0; i < waypoints.length; ++i) {
      // TODO: Unsafe if two points with same position
      if (wpActive[i] && waypoints[i].equals(latLng)) {
        labels[i] = label;
        return true;
      }
    }
    return false;
  };

  BpTspSolver.prototype.removeWaypoint = function(latLng) {
    for (var i = 0; i < waypoints.length; ++i) {
      if (wpActive[i] && waypoints[i].equals(latLng)) {
        wpActive[i] = false;
        return true;
      }
    }
    return false;
  };

  BpTspSolver.prototype.removeAddress = function(addr) {
    for (var i = 0; i < addresses.length; ++i) {
      if (wpActive[i] && addresses[i] == addr) {
        wpActive[i] = false;
        return true;
      }
    }
    return false;
  };

  BpTspSolver.prototype.setAsStop = function(latLng) {
    var j = -1;
    for (var i = waypoints.length - 1; i >= 0; --i) {
      if (j == -1 && wpActive[i]) {
        j = i;
      }
      if (wpActive[i] && waypoints[i].equals(latLng)) {
        for (var k = i; k < j; ++k) {
          swapWaypoints(k, k + 1);
        }
        break;
      }
    }
  }

  BpTspSolver.prototype.setAsStart = function(latLng) {
    var j = -1;
    for (var i = 0; i < waypoints.length; ++i) {
      if (j == -1 && wpActive[i]) {
        j = i;
      }
      if (wpActive[i] && waypoints[i].equals(latLng)) {
        for (var k = i; k > j; --k) {
          swapWaypoints(k, k - 1);
        }
        break;
      }
    }
  }

  BpTspSolver.prototype.getGDirections = function() {
    return gebDirectionsResult;
  };

  BpTspSolver.prototype.getGDirectionsService = function() {
    return gebDirectionsService;
  };

  // Returns the order that the input locations was visited in.
  //   getOrder()[0] is always the starting location.
  //   getOrder()[1] gives the first location visited, getOrder()[2]
  //   gives the second location visited and so on.
  BpTspSolver.prototype.getOrder = function() {
    return bestPath;
  }

  // Methods affecting the way driving directions are computed
  BpTspSolver.prototype.getAvoidHighways = function() {
    return avoidHighways;
  }

  BpTspSolver.prototype.setAvoidHighways = function(avoid) {
    avoidHighways = avoid;
  }

  BpTspSolver.prototype.getAvoidTolls = function() {
    return avoidTolls;
  }

  BpTspSolver.prototype.setAvoidTolls = function(avoid) {
    avoidTolls = avoid;
  }

  BpTspSolver.prototype.getTravelMode = function() {
    return travelMode;
  }

  BpTspSolver.prototype.setTravelMode = function(travelM) {
    travelMode = travelM;
  }

  BpTspSolver.prototype.getDurations = function() {
    return dur;
  }

  // Helper functions
  BpTspSolver.prototype.getTotalDuration = function() {
    return gebDirections.getDuration().seconds;
  }

  // we assume that we have enough waypoints
  BpTspSolver.prototype.isReady = function() {
    return addressRequests == 0;
  };

  BpTspSolver.prototype.solveRoundTrip = function(callback) {
    if (doNotContinue) {
      alert('Cannot continue after fatal errors.');
      return;
    }

    if (!this.isReady()) {
      setTimeout(function() {
        tsp.solveRoundTrip(callback)
      }, 20);
      return;
    }
    if (typeof callback == 'function')
      onSolveCallback = callback;

    directions(0);
  };

  BpTspSolver.prototype.solveAtoZ = function(callback) {
    if (doNotContinue) {
      alert('Cannot continue after fatal errors.');
      return;
    }

    if (!this.isReady()) {
      setTimeout(function() {
        tsp.solveAtoZ(callback)
      }, 20);
      return;
    }

    if (typeof callback == 'function')
      onSolveCallback = callback;

    directions(1);
  };

  BpTspSolver.prototype.solveOrderedTrip = function(callback) {
    if (doNotContinue) {
      alert('Cannot continue after fatal errors.');
      return;
    }

    if (!this.isReady()) {
      setTimeout(function() {
        tsp.solveOrderedTrip(callback)
      }, 20);
      return;
    }

    if (typeof callback == 'function')
      onSolveCallback = callback;

    directions(2);
  };

  BpTspSolver.prototype.setDirectionUnits = function(mOrKm) {
    if (mOrKm == "m") {
      directionunits = google.maps.UnitSystem.IMPERIAL;
    } else {
      directionunits = google.maps.UnitSystem.METRIC;
    }
  }

  BpTspSolver.prototype.setOnProgressCallback = function(callback) {
    onProgressCallback = callback;
  }

  BpTspSolver.prototype.getNumDirectionsComputed = function() {
    return numDirectionsComputed;
  }

  BpTspSolver.prototype.getNumDirectionsNeeded = function() {
    return numDirectionsNeeded;
  }

  BpTspSolver.prototype.reverseSolution = function() {
    reverseSolution();
  }

  BpTspSolver.prototype.reorderSolution = function(newOrder, callback) {
    if (typeof callback == 'function')
      onSolveCallback = callback;

    reorderSolution(newOrder);
  }

  BpTspSolver.prototype.removeStop = function(number, callback) {
    if (typeof callback == 'function')
      onSolveCallback = callback;

    removeStop(number);
  }

  window.BpTspSolver = BpTspSolver;

})();